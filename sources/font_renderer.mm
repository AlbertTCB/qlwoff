#import "font_renderer.h"

/* 
 most of this is taken from freetype.org : http://www.freetype.org/freetype2/docs/tutorial/example2.cpp
 Replaced structs name to avoid some collisions
 */
#include <ft2build.h>
#include FT_FREETYPE_H
#include FT_STROKER_H

#include <vector>
#include <fstream>
#include <iostream>


NYX_EXTERN_C_BEGIN

#pragma mark - Structs
union NYXPixel32
{
	NYXPixel32() : integer(0) {}
	NYXPixel32(uint8 bi, uint8 gi, uint8 ri, uint8 ai = 255)
	{
		b = bi;
		g = gi;
		r = ri;
		a = ai;
	}

	uint32 integer;

	struct
	{
		uint8 b, g, r, a;
	};
};

struct NYXVec2
{
	NYXVec2() {}
	NYXVec2(float a, float b)
	: x(a), y(b) {}

	float x, y;
};

struct NYXRect
{
	NYXRect() {}
	NYXRect(float left, float top, float right, float bottom)
	: xmin(left), xmax(right), ymin(top), ymax(bottom) {}

	void Include(const NYXVec2 &r)
	{
		xmin = MIN(xmin, r.x);
		ymin = MIN(ymin, r.y);
		xmax = MAX(xmax, r.x);
		ymax = MAX(ymax, r.y);
	}

	float Width() const { return xmax - xmin + 1; }
	float Height() const { return ymax - ymin + 1; }

	float xmin, xmax, ymin, ymax;
};

// A horizontal pixel span generated by the FreeType renderer.
struct NYXSpan
{
	NYXSpan() {}
	NYXSpan(int _x, int _y, int _width, int _coverage)
	: x(_x), y(_y), width(_width), coverage(_coverage) { }

	int x, y, width, coverage;
};
typedef std::vector<NYXSpan> Spans;


#pragma mark - Functions declaration
static void RasterCallback(const int y, const int count, const FT_Span* const spans, void* const user);
static void RenderSpans(FT_Library& library, FT_Outline* const outline, Spans* spans);

#pragma mark - Global
#define NYX_SAMPLESTRING_LEN 66
#define NYX_MAX_LINE_LEN 13
static char sample_string[NYX_SAMPLESTRING_LEN + 1] = "ABCDEFGHIJKLM\nNOPQRSTUVWXYZ\nabcdefghijklm\nnopqrstuvwxyz\n0123456789";


#pragma mark - Functions implementation
// Each time the renderer calls us back we just push another span entry on our list.
void RasterCallback(const int y, const int count, const FT_Span* const spans, void* const user)
{
	Spans* sptr = (Spans*)user;
	for (int i = 0; i < count; ++i)
		sptr->push_back(NYXSpan(spans[i].x, y, spans[i].len, spans[i].coverage));
}

// Set up the raster parameters and render the outline.
void RenderSpans(FT_Library& library, FT_Outline* const outline, Spans* spans)
{
	FT_Raster_Params params;
	memset(&params, 0, sizeof(params));
	params.flags = FT_RASTER_FLAG_AA | FT_RASTER_FLAG_DIRECT;
	params.gray_spans = RasterCallback;
	params.user = spans;
	FT_Outline_Render(library, outline, &params);
}

CF_RETURNS_RETAINED CGImageRef create_image_for_font_at_url(NSString* path)
{
	// Initialize FreeType once
	static FT_Library library  = NULL;
	static dispatch_once_t onceToken;
	dispatch_once(&onceToken, ^{
		FT_Init_FreeType(&library);
	});

	// Open up a font file
	std::ifstream fontFile([path UTF8String], std::ios::binary);
	if (!fontFile)
		return NULL;

	// Read the entire file to a memory buffer
	fontFile.seekg(0, std::ios::end);
	std::fstream::pos_type fontFileSize = fontFile.tellg();
	fontFile.seekg(0);
	unsigned char* fontBuffer = new unsigned char[fontFileSize];
	fontFile.read((char*)fontBuffer, fontFileSize);

	// Create a face from a memory buffer. Be sure not to delete the memory
	// buffer until you are done using that font as FreeType will reference it directly
	FT_Face face;
	FT_New_Memory_Face(library, fontBuffer, fontFileSize, 0, &face);

	// Set the font size to use
	const int size = 48;
	if (FT_Set_Char_Size(face, size << 6, size << 6, 90, 90) != 0)
		return NULL;

	std::vector<NYXRect> vrect;
	std::vector<NYXPixel32*> vimg;
	float imgWidth = 0.0f, imgHeight = 0.0f;
	float finalWidth = 0.0f, finalHeight = 0.0f;
	const float x_space = 4.0f, y_space = 10.0f;
	const float outlineWidth = 1.0f;
	const NYXPixel32& fontColor = NYXPixel32(0, 0, 0);
	const NYXPixel32 outlineColor = NYXPixel32(0, 0, 0);
	for (size_t i = 0; i < NYX_SAMPLESTRING_LEN; i++)
	{
		if (sample_string[i] == '\n')
		{
			if (imgWidth > finalWidth)
				finalWidth = imgWidth;
			imgWidth = 0.0;
			finalHeight += imgHeight;
			continue;
		}

		// Load the glyph we are looking for.
		FT_UInt gindex = FT_Get_Char_Index(face, (FT_ULong)sample_string[i]);
		if (FT_Load_Glyph(face, gindex, FT_LOAD_NO_BITMAP) == 0)
		{
			// Need an outline for this to work.
			if (face->glyph->format == FT_GLYPH_FORMAT_OUTLINE)
			{
				// Render the basic glyph to a span list.
				Spans spans;
				RenderSpans(library, &face->glyph->outline, &spans);

				// Next we need the spans for the outline.
				Spans outlineSpans;

				// Set up a stroker.
				FT_Stroker stroker;
				FT_Stroker_New(library, &stroker);
				FT_Stroker_Set(stroker, (int)(outlineWidth * 64), FT_STROKER_LINECAP_ROUND, FT_STROKER_LINEJOIN_ROUND, 0);

				FT_Glyph glyph;
				if (FT_Get_Glyph(face->glyph, &glyph) == 0)
				{
					FT_Glyph_StrokeBorder(&glyph, stroker, 0, 1);
					// Again, this needs to be an outline to work.
					if (glyph->format == FT_GLYPH_FORMAT_OUTLINE)
					{
						// Render the outline spans to the span list
						FT_Outline* o = &reinterpret_cast<FT_OutlineGlyph>(glyph)->outline;
						RenderSpans(library, o, &outlineSpans);
					}

					// Clean up afterwards.
					FT_Stroker_Done(stroker);
					FT_Done_Glyph(glyph);

					// Now we need to put it all together.
					if (!spans.empty())
					{
						// Figure out what the bounding rect is for both the span lists.
						NYXRect rect(spans.front().x, spans.front().y, spans.front().x, spans.front().y);
						for (Spans::iterator s = spans.begin(); s != spans.end(); ++s)
						{
							rect.Include(NYXVec2(s->x, s->y));
							rect.Include(NYXVec2(s->x + s->width - 1, s->y));
						}
						for (Spans::iterator s = outlineSpans.begin(); s != outlineSpans.end(); ++s)
						{
							rect.Include(NYXVec2(s->x, s->y));
							rect.Include(NYXVec2(s->x + s->width - 1, s->y));
						}
						vrect.push_back(rect);

						// Get some metrics of our image.
						const float tmpWidth = ceilf(rect.Width());
						const float tmpHeight = ceilf(rect.Height());
						imgWidth += tmpWidth;
						if (tmpHeight > imgHeight)
							imgHeight = tmpHeight;
						const size_t imgSize = (size_t)(tmpWidth * tmpHeight);

						// Allocate data for our image and clear it out to transparent.
						NYXPixel32* pxl = new NYXPixel32[imgSize];
						memset(pxl, 0, sizeof(NYXPixel32) * imgSize);

						// Loop over the outline spans and just draw them into the image.
						for (Spans::iterator s = outlineSpans.begin(); s != outlineSpans.end(); ++s)
							for (int w = 0; w < s->width; ++w)
								pxl[(int)((tmpHeight - 1 - (s->y - rect.ymin)) * tmpWidth + s->x - rect.xmin + w)] = NYXPixel32(outlineColor.r, outlineColor.g, outlineColor.b, (uint8)s->coverage);

						// Then loop over the regular glyph spans and blend them into the image.
						for (Spans::iterator s = spans.begin(); s != spans.end(); ++s)
						{
							for (int w = 0; w < s->width; ++w)
							{
								NYXPixel32 &dst = pxl[(int)((tmpHeight - 1 - (s->y - rect.ymin)) * tmpWidth + s->x - rect.xmin + w)];
								NYXPixel32 src = NYXPixel32(fontColor.r, fontColor.g, fontColor.b, (uint8)s->coverage);
								dst.r = (uint8)(dst.r + ((src.r - dst.r) * src.a) / 255.0f);
								dst.g = (uint8)(dst.g + ((src.g - dst.g) * src.a) / 255.0f);
								dst.b = (uint8)(dst.b + ((src.b - dst.b) * src.a) / 255.0f);
								dst.a = (uint8)MIN(255, dst.a + src.a);
							}
						}
						vimg.push_back(pxl);
					}
				}
			}
		}
	}
	finalHeight += (imgHeight + (4 * y_space));
	finalWidth += (12 * x_space);
	finalWidth = ceilf(finalWidth);
	finalHeight = ceilf(finalHeight);

	CGColorSpaceRef cs = CGColorSpaceCreateDeviceRGB();
	CGContextRef bmContext = CGBitmapContextCreate(NULL, (size_t)finalWidth, (size_t)finalHeight, 8, 4 * (size_t)finalWidth, cs, kCGBitmapByteOrderDefault | kCGImageAlphaPremultipliedLast);
	float x = 0.0, y = finalHeight;
	CGFloat taller = 0;
	for (size_t i = 0, line_len = 1; i < vimg.size(); i++, line_len++)
	{
		NYXPixel32* pxl = vimg[i];
		NYXRect rect = vrect[i];
		const float width = ceilf(rect.Width());
		const float height = ceilf(rect.Height());

		CFDataRef data = CFDataCreate(kCFAllocatorDefault, (UInt8*)pxl, (CFIndex)width * (CFIndex)height * (CFIndex)sizeof(NYXPixel32));
		CGDataProviderRef dp = CGDataProviderCreateWithCFData(data);
		CGImageRef imgRef = CGImageCreate((size_t)width, (size_t)height, 8, 32, 4 * (size_t)width, cs, kCGBitmapByteOrderDefault | kCGImageAlphaPremultipliedLast, dp, NULL, true, kCGRenderingIntentDefault);

		const CGFloat goodY = y - height;
		const CGRect area = (CGRect){.origin.x = x, .origin.y = goodY, .size.width = width, .size.height = height};
		CGContextDrawImage(bmContext, area, imgRef);

		x+= width + x_space;
		if (NYX_MAX_LINE_LEN == line_len)
		{
			y -= (taller + y_space);
			x = 0.0;
			taller = 0.0;
			line_len = 0;
		}
		if (height > taller)
			taller = height;

		CGImageRelease(imgRef);
		CFRelease(dp);
		CFRelease(data);
		delete [] pxl;
	}
	CGImageRef ret = CGBitmapContextCreateImage(bmContext);
	CGContextRelease(bmContext);
	CGColorSpaceRelease(cs);

	delete [] fontBuffer;

	return ret;
}

NYX_EXTERN_C_END
